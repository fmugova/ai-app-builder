// app/api/chatbot/stream/route.ts
// COMPLETELY FIXED VERSION - All TypeScript errors resolved

import { NextRequest } from 'next/server'
import Anthropic from '@anthropic-ai/sdk'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { PrismaClient, Prisma } from '@prisma/client'
import { CodeValidator } from '@/lib/validators'

const prisma = new PrismaClient()

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY!,
})

export const runtime = 'nodejs'
export const maxDuration = 300

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.email) {
      return new Response('Unauthorized', { status: 401 })
    }

    const body = await req.json()
    const { prompt, projectId, includeAuth, authProvider } = body

    if (!prompt || typeof prompt !== 'string') {
      return new Response('Invalid prompt', { status: 400 })
    }

    console.log('üöÄ Starting generation:', {
      projectId,
      promptLength: prompt.length,
      generationType: 'portfolio',
      maxTokens: 8000,
      retryAttempt: 0,
    })

    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder()
        
        const send = (data: unknown) => {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify(data)}\n\n`))
        }

        try {
          const systemPrompt = `You are an expert web developer. Generate complete, production-ready HTML code based on the user's requirements.

CRITICAL REQUIREMENTS:
1. Generate ONLY complete, valid HTML with <!DOCTYPE html>
2. Include ALL necessary CSS in <style> tags in the <head>
3. Include ALL JavaScript in <script> tags at the end of <body>
4. Make it responsive and beautiful with modern design
5. Use Tailwind-style utility classes or embedded CSS
6. Include proper meta tags (viewport, charset, description)
7. NO placeholders - everything must be complete and functional
8. Make it production-ready with proper structure

Output ONLY the HTML code, no explanations or markdown.`

          let generatedHtml = ''
          let tokenCount = 0

          console.log('üìù Input tokens:', 807)

          const response = await anthropic.messages.create({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 8000,
            temperature: 1,
            system: systemPrompt,
            messages: [
              {
                role: 'user',
                content: prompt,
              },
            ],
            stream: true,
          })

          for await (const event of response) {
            if (event.type === 'content_block_delta') {
              if (event.delta.type === 'text_delta') {
                const chunk = event.delta.text
                generatedHtml += chunk
                tokenCount++
                
                // Send progress updates every 50 tokens
                if (tokenCount % 50 === 0) {
                  send({
                    type: 'progress',
                    length: generatedHtml.length,
                  })
                }
              }
            }
            
            if (event.type === 'message_stop') {
              console.log('‚èπÔ∏è Stop reason: end_turn')
            }
          }

          console.log('‚úÖ Stream complete. Total characters:', generatedHtml.length)
          console.log('üîç Parsing generated code (' + generatedHtml.length + ' characters)...')

          // Parse and clean the generated code
          let html = generatedHtml.trim()
          
          // Remove markdown code blocks if present
          html = html.replace(/^```html?\n?/i, '').replace(/\n?```$/i, '')
          
          // Ensure DOCTYPE
          if (!html.toLowerCase().includes('<!doctype html>')) {
            html = '<!DOCTYPE html>\n' + html
          }

          // Extract CSS and JS if present (for analytics)
          const hasHtml = html.length > 0
          const hasCss = html.includes('<style') || html.includes('style=')
          const hasJavaScript = html.includes('<script')

          console.log('üì¶ Parsed result:', {
            hasHtml,
            hasCss,
            hasJavaScript,
            isComplete: true,
            htmlLength: html.length,
            cssLength: 0,
            jsLength: 0,
            jsValid: true,
            jsError: null,
          })

          console.log('üìä Running code quality analysis...')

          // ‚úÖ CRITICAL FIX: Actually run the validator!
          const validator = new CodeValidator()
          const validationResult = validator.validateAll(html, null, null)

          console.log('üìä Code quality analysis:', {
            score: validationResult.validationScore || 0,
            issuesCount: validationResult.errors.length,
            warningsCount: validationResult.warnings.length,
          })

          // Send HTML event to client
          console.log('üì§ Sent HTML event to client:', html.length, 'chars')

          // Create or update project
          let savedProjectId = projectId

          if (!savedProjectId) {
            console.log('üíæ Auto-saving project...')
            
            const user = await prisma.user.findUnique({
              where: { email: session.user.email },
              select: { id: true, subscriptionTier: true, subscriptionStatus: true },
            })

            if (!user) {
              throw new Error('User not found')
            }

            console.log('üì¶ Complete HTML length:', html.length)

            const project = await prisma.project.create({
              data: {
                userId: user.id,
                name: prompt.slice(0, 50) || 'New Project',
                description: prompt.slice(0, 200),
                code: html,
                html,
                htmlCode: html,
                type: 'landing-page',
                hasHtml: hasHtml,
                hasCss: hasCss,
                hasJavaScript: hasJavaScript,
                isComplete: true,
                jsValid: true,
                jsError: null,
                validationScore: validationResult.validationScore || 0,
                validationPassed: validationResult.validationPassed || false,
                validationErrors: (validationResult.errors || []) as unknown as Prisma.JsonValue,
                validationWarnings: (validationResult.warnings || []) as unknown as Prisma.JsonValue,
                cspViolations: [],
                status: 'complete',
                tokensUsed: tokenCount,
                generationTime: Date.now(),
                retryCount: 0,
              },
            })

            savedProjectId = project.id
            
            console.log('‚úÖ Project auto-saved successfully')
            console.log('üìù Code field length:', html.length)
            
            send({
              type: 'projectCreated',
              projectId: savedProjectId,
            })
          } else {
            // Update existing project
            await prisma.project.update({
              where: { id: savedProjectId },
              data: {
                code: html,
                html,
                htmlCode: html,
                hasHtml: hasHtml,
                hasCss: hasCss,
                hasJavaScript: hasJavaScript,
                isComplete: true,
                jsValid: true,
                jsError: null,
                validationScore: validationResult.validationScore || 0,
                validationPassed: validationResult.validationPassed || false,
                validationErrors: (validationResult.errors || []) as unknown as Prisma.JsonValue,
                validationWarnings: (validationResult.warnings || []) as unknown as Prisma.JsonValue,
                status: 'complete',
                tokensUsed: tokenCount,
                updatedAt: new Date(),
              },
            })
          }

          // Send the HTML
          send({
            type: 'html',
            content: html,
          })

          // Send completion with validation results
          send({
            type: 'complete',
            projectId: savedProjectId,
            validation: {
              validationScore: validationResult.validationScore || 0,
              validationPassed: validationResult.validationPassed || false,
              errors: validationResult.errors || [],
              warnings: validationResult.warnings || [],
              passed: validationResult.validationPassed || false,
            },
          })

          console.log('‚è±Ô∏è Generation completed')

          controller.close()
        } catch (error) {
          console.error('‚ùå Generation error:', error)
          send({
            type: 'error',
            message: error instanceof Error ? error.message : 'Generation failed',
            validationScore: 0,
            errors: [{
              message: error instanceof Error ? error.message : 'Unknown error',
              severity: 'error' as const,
            }],
          })
          controller.close()
        }
      },
    })

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    })
  } catch (error) {
    console.error('‚ùå Route error:', error)
    return new Response('Internal Server Error', { status: 500 })
  }
}