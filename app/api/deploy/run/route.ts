// app/api/deploy/run/route.ts
// Background worker: creates GitHub repo, pushes project files, triggers Vercel.
// Called by /api/deploy/start (fire-and-forget via internal fetch).
// All progress is written to Upstash Redis so /api/deploy/job can poll it.
import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'
import { decrypt } from '@/lib/encryption'
import { redis } from '@/lib/rate-limit'

export const dynamic = 'force-dynamic'
// Allow up to 5 minutes for the full deploy pipeline
export const maxDuration = 300

const REDIS_AVAILABLE = !!process.env.UPSTASH_REDIS_REST_URL?.startsWith('https://')

const JOB_TTL = 60 * 30 // 30 minutes

// ── Types ─────────────────────────────────────────────────────────────────

interface JobPayload {
  jobId: string
  projectId: string
  userId: string
  repoName: string
  privateRepo: boolean
}

type DeployStep = 'createRepo' | 'pushCode' | 'triggerVercel' | 'waitForReady'

// ── Redis helpers ─────────────────────────────────────────────────────────

async function updateJob(jobId: string, updates: Record<string, unknown>) {
  const raw = await redis.get<string>(`deploy:job:${jobId}`)
  const current = typeof raw === 'string' ? JSON.parse(raw) : (raw ?? {})
  const merged = { ...current, ...updates }
  await redis.setex(`deploy:job:${jobId}`, JOB_TTL, JSON.stringify(merged))
}

async function failJob(jobId: string, step: DeployStep, message: string) {
  await updateJob(jobId, { status: 'error', step, message })
}

// ── GitHub API helpers ────────────────────────────────────────────────────

async function ghFetch(token: string, path: string, options?: RequestInit) {
  const res = await fetch(`https://api.github.com${path}`, {
    ...options,
    headers: {
      'Authorization': `Bearer ${token}`,
      'Accept': 'application/vnd.github+json',
      'X-GitHub-Api-Version': '2022-11-28',
      'Content-Type': 'application/json',
      ...(options?.headers ?? {}),
    },
  })
  return res
}

/** Create a new GitHub repo; returns { repoFullName, cloneUrl, htmlUrl } */
async function createGitHubRepo(
  token: string,
  repoName: string,
  isPrivate: boolean,
): Promise<{ repoFullName: string; htmlUrl: string }> {
  const res = await ghFetch(token, '/user/repos', {
    method: 'POST',
    body: JSON.stringify({
      name: repoName,
      private: isPrivate,
      auto_init: false,
      description: 'Generated by BuildFlow AI',
    }),
  })
  if (!res.ok) {
    const err = await res.json().catch(() => ({}))
    throw new Error(err.message ?? `GitHub create repo failed (${res.status})`)
  }
  const data = await res.json()
  return { repoFullName: data.full_name, htmlUrl: data.html_url }
}

/** Upsert files into a GitHub repo via the Contents API (base64, one file at a time). */
async function pushFilesToRepo(
  token: string,
  repoFullName: string,
  files: Record<string, string>,
): Promise<void> {
  const entries = Object.entries(files)
  // Push files in small batches to avoid rate limits
  for (const [path, content] of entries) {
    // Skip binary-ish paths and hidden dirs we don't need
    if (path.startsWith('.git/') || path.startsWith('node_modules/')) continue

    const encoded = Buffer.from(content, 'utf8').toString('base64')

    // Check if file already exists (for upsert)
    let sha: string | undefined
    const checkRes = await ghFetch(token, `/repos/${repoFullName}/contents/${path}`)
    if (checkRes.ok) {
      const existing = await checkRes.json()
      sha = existing.sha
    }

    const putRes = await ghFetch(token, `/repos/${repoFullName}/contents/${path}`, {
      method: 'PUT',
      body: JSON.stringify({
        message: sha ? `update ${path}` : `add ${path}`,
        content: encoded,
        ...(sha ? { sha } : {}),
      }),
    })
    if (!putRes.ok) {
      const err = await putRes.json().catch(() => ({}))
      throw new Error(`Failed to push ${path}: ${err.message ?? putRes.status}`)
    }
  }
}

// ── Vercel API helpers ────────────────────────────────────────────────────

async function vcFetch(token: string, path: string, teamId: string | null, options?: RequestInit) {
  const qs = teamId ? `?teamId=${encodeURIComponent(teamId)}` : ''
  const res = await fetch(`https://api.vercel.com${path}${qs}`, {
    ...options,
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
      ...(options?.headers ?? {}),
    },
  })
  return res
}

/** Link GitHub repo to Vercel and trigger a deploy; returns deploymentUrl + logsUrl */
async function triggerVercelDeploy(
  token: string,
  teamId: string | null,
  repoFullName: string,
  projectName: string,
): Promise<{ deploymentUrl: string; logsUrl: string; projectId: string }> {
  // Try to create a new Vercel project linked to the GitHub repo
  const createRes = await vcFetch(token, '/v10/projects', teamId, {
    method: 'POST',
    body: JSON.stringify({
      name: projectName,
      framework: 'nextjs',
      gitRepository: {
        type: 'github',
        repo: repoFullName,
      },
    }),
  })

  let vercelProjectId: string

  if (createRes.ok) {
    const project = await createRes.json()
    vercelProjectId = project.id
  } else if (createRes.status === 409) {
    // Project already exists — fetch it
    const listRes = await vcFetch(token, `/v9/projects/${encodeURIComponent(projectName)}`, teamId)
    if (!listRes.ok) throw new Error(`Vercel project lookup failed (${listRes.status})`)
    const existing = await listRes.json()
    vercelProjectId = existing.id
  } else {
    const err = await createRes.json().catch(() => ({}))
    throw new Error(err.error?.message ?? `Vercel project creation failed (${createRes.status})`)
  }

  // Trigger a deploy
  const deployRes = await vcFetch(token, '/v13/deployments', teamId, {
    method: 'POST',
    body: JSON.stringify({
      name: projectName,
      gitSource: {
        type: 'github',
        repo: repoFullName,
        ref: 'main',
      },
      projectId: vercelProjectId,
      target: 'production',
    }),
  })

  if (!deployRes.ok) {
    const err = await deployRes.json().catch(() => ({}))
    throw new Error(err.error?.message ?? `Vercel deploy trigger failed (${deployRes.status})`)
  }

  const deploy = await deployRes.json()
  const deploymentUrl = `https://${deploy.url}`
  const logsUrl = `https://vercel.com/${teamId ? `${teamId}/` : ''}${projectName}/${deploy.id}`

  return { deploymentUrl, logsUrl, projectId: vercelProjectId }
}

/** Poll Vercel until the deployment is READY or ERROR. Returns final URL. */
async function waitForVercelReady(
  token: string,
  teamId: string | null,
  deploymentId: string,
  jobId: string,
  deploymentUrl: string,
): Promise<string> {
  const maxAttempts = 60 // 5 min at 5s intervals
  const interval = 5000

  for (let i = 0; i < maxAttempts; i++) {
    await new Promise(r => setTimeout(r, interval))

    const qs = teamId ? `?teamId=${encodeURIComponent(teamId)}` : ''
    const res = await fetch(`https://api.vercel.com/v13/deployments/${deploymentId}${qs}`, {
      headers: { 'Authorization': `Bearer ${token}` },
    })
    if (!res.ok) continue

    const data = await res.json()
    const state: string = data.readyState ?? data.state ?? ''

    // Update Redis with current URL so UI can show it
    await updateJob(jobId, {
      step: 'waitForReady',
      message: `Build ${state.toLowerCase()}… (${i + 1}/${maxAttempts})`,
      vercelDeploymentUrl: `https://${data.url ?? deploymentUrl.replace('https://', '')}`,
    })

    if (state === 'READY') return `https://${data.url}`
    if (state === 'ERROR' || state === 'CANCELED') {
      throw new Error(`Vercel deployment ${state.toLowerCase()}`)
    }
  }

  throw new Error('Vercel deployment timed out after 5 minutes')
}

// ── Route handler ─────────────────────────────────────────────────────────

export async function POST(req: NextRequest) {
  if (!REDIS_AVAILABLE) {
    return NextResponse.json({ error: 'Deployment requires Upstash Redis.' }, { status: 503 })
  }
  // Validate internal secret
  const secret = req.headers.get('x-deploy-secret') ?? ''
  if (!secret || secret !== (process.env.DEPLOY_JOB_SECRET ?? '')) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 })
  }

  let payload: JobPayload
  try {
    payload = await req.json()
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 })
  }

  const { jobId, projectId, userId, repoName, privateRepo } = payload
  if (!jobId || !projectId || !userId) {
    return NextResponse.json({ error: 'Missing required fields' }, { status: 400 })
  }

  // Respond immediately — actual work happens async
  // (The long work is awaited in the background via the edge/serverless function timeout)
  runDeploy({ jobId, projectId, userId, repoName, privateRepo }).catch(async (e) => {
    console.error('[deploy/run] Unhandled error:', e)
    await failJob(jobId, 'createRepo', e?.message ?? 'Unexpected error')
  })

  return NextResponse.json({ accepted: true })
}

// ── Core deploy logic (async, runs after response is sent) ───────────────

async function runDeploy({ jobId, projectId, userId, repoName, privateRepo }: JobPayload) {
  // ── Load user credentials ──────────────────────────────────────────────
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: {
      githubAccessToken: true,
      vercelToken: true,
      vercelTeamId: true,
    },
  })

  if (!user?.githubAccessToken) {
    await failJob(jobId, 'createRepo', 'GitHub not connected — please connect GitHub in settings')
    return
  }
  if (!user?.vercelToken) {
    await failJob(jobId, 'triggerVercel', 'Vercel not connected — please connect Vercel in settings')
    return
  }

  const ghToken = decrypt(user.githubAccessToken)
  const vcToken = user.vercelToken  // stored plain
  const vcTeamId = user.vercelTeamId ?? null

  // ── Load project files ─────────────────────────────────────────────────
  const fileRows = await (prisma.projectFile as any).findMany({
    where: { projectId },
    select: { path: true, content: true },
  })
  const files: Record<string, string> = {}
  for (const row of fileRows ?? []) {
    if (row.path && row.content != null) files[row.path] = row.content
  }

  if (Object.keys(files).length === 0) {
    await failJob(jobId, 'createRepo', 'Project has no files to deploy')
    return
  }

  // ── Step 1: Create GitHub repo ─────────────────────────────────────────
  await updateJob(jobId, { step: 'createRepo', status: 'running', message: 'Creating GitHub repository…' })

  let repoFullName: string
  let repoHtmlUrl: string

  try {
    const result = await createGitHubRepo(ghToken, repoName, privateRepo)
    repoFullName = result.repoFullName
    repoHtmlUrl = result.htmlUrl
    await updateJob(jobId, { repoUrl: repoHtmlUrl, message: `Repository ${repoFullName} created` })
  } catch (e: any) {
    await failJob(jobId, 'createRepo', e?.message ?? 'Failed to create GitHub repository')
    return
  }

  // ── Step 2: Push code ──────────────────────────────────────────────────
  await updateJob(jobId, { step: 'pushCode', message: `Pushing ${Object.keys(files).length} files…` })

  try {
    await pushFilesToRepo(ghToken, repoFullName, files)
    await updateJob(jobId, { message: 'Code pushed to GitHub' })
  } catch (e: any) {
    await failJob(jobId, 'pushCode', e?.message ?? 'Failed to push code to GitHub')
    return
  }

  // ── Step 3: Trigger Vercel ─────────────────────────────────────────────
  await updateJob(jobId, { step: 'triggerVercel', message: 'Triggering Vercel deployment…' })

  let deploymentUrl: string
  let logsUrl: string
  let vercelDeploymentId: string

  try {
    const result = await triggerVercelDeploy(vcToken, vcTeamId, repoFullName, repoName)
    deploymentUrl = result.deploymentUrl
    logsUrl = result.logsUrl
    vercelDeploymentId = result.projectId // reuse as deployment ref
    await updateJob(jobId, {
      vercelDeploymentUrl: deploymentUrl,
      vercelLogsUrl: logsUrl,
      message: 'Vercel build triggered',
    })
  } catch (e: any) {
    await failJob(jobId, 'triggerVercel', e?.message ?? 'Failed to trigger Vercel deployment')
    return
  }

  // ── Step 4: Wait for ready ─────────────────────────────────────────────
  await updateJob(jobId, { step: 'waitForReady', message: 'Waiting for build to complete…' })

  try {
    const finalUrl = await waitForVercelReady(vcToken, vcTeamId, vercelDeploymentId, jobId, deploymentUrl)
    await updateJob(jobId, {
      status: 'success',
      step: 'waitForReady',
      vercelDeploymentUrl: finalUrl,
      message: 'Deployment ready',
    })
  } catch (e: any) {
    await failJob(jobId, 'waitForReady', e?.message ?? 'Deployment did not become ready')
  }
}
